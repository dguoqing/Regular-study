<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Document</title>
</head>
<body>

  <script>
    /*
      正则表达式的标识符
        + 标识符是写在正则表达式的外面, 用来修饰整个正则表达式的
        + 标识符
          1. i   忽略大小写
          2. g   全局
          3. y   粘性全局
        + 语法:
          => /abcd/igy
          => new RegExp('abcd', 'igy')
    */

    // 1. i 忽略大小写
    // const reg = /^[abcd]*$/
    // console.log(reg.test('abcdacbd'))
    // console.log(reg.test('abcdA'))

    // const reg2 = /^[abcd]*$/i
    // console.log(reg2.test('abcdacbd'))
    // console.log(reg2.test('abcdA'))


    // 2. g 全局
    //    匹配和捕获的时候, 都是只能找到第一个
    //    当他有全局标识符的时候, 你捕获第二次会从第一次的结束位开始查找
    //    知道找不到了, 返回 null
    //    再后面依次的时候, 又回到 [0] 位置开始捕获
    //    匹配和捕获都是影响下一次开始位的
    // const str = 'abc123abc456abc789abc'
    // const reg = /\d{3}/g
    // console.log(reg.exec(str)) // 结束位是 [5]
    // console.log(reg.exec(str)) // 开始位就是 [6]
    // console.log(reg.test(str)) // 开始位就是 [12]
    // console.log(reg.exec(str)) // 开始位就是 [15]
    // console.log(reg.exec(str)) // 开始位就是 [0]


    // 3. y 粘性全局
    //    每一次捕获的时候
    //    第一次必须是从 [0] 位置就刚好能捕获到内容
    //    第二次必须是从 第一次结束位开始 就刚好能捕获到内容才可以
    // const str = '123456abc789abc'
    // const reg = /\d{3}/y
    // console.log(reg.exec(str)) // g 123
    // console.log(reg.exec(str)) // g 456

    // console.log(reg.exec(str)) // 123
    // console.log(reg.exec(str)) // 456
  </script>
</body>
</html>
